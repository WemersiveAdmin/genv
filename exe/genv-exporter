#!/usr/bin/env python3

import argparse
import asyncio
import sys
import time

import genv

try:
    from genv.metrics import Collection, Metric, Type, publish_config_files, SPECS
    import prometheus_client
except ModuleNotFoundError as e:
    if e.name != "prometheus_client":
        raise

    print(f"ERROR: Python package '{e.name}' is required", file=sys.stderr)
    exit(1)


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser()

    parser.add_argument(
        "--config-dir",
        default=genv.utils.get_temp_file_path("metrics"),
        help="Directory to create Prometheus and Grafana config files at (default: %(default)s)",
    )

    parser.add_argument(
        "-p",
        "--port",
        type=int,
        default=8000,
        help="Port to listen on (default: %(default)s)",
    )

    parser.add_argument(
        "-i",
        "--interval",
        type=int,
        default=10,
        help="Interval in seconds between collections (default: %(default)s)",
    )

    return parser.parse_args()


METRICS = Collection(
    {
        name: Metric(
            spec.name,
            spec.documentation,
            spec.labelnames,
            type=spec.type,
            convert=spec.convert,
            filter=spec.filter,
        )
        for name, spec in SPECS.items()
    }
)


def system(snapshot: genv.Snapshot) -> None:
    for metric in METRICS.filter(Type.System):
        metric.set(snapshot)


def environment(env: genv.envs.Env, snapshot: genv.Snapshot) -> None:
    labels = dict(eid=env.eid)

    for metric in METRICS.filter(Type.Environment):
        metric.labels(**labels).set(snapshot)


def process(process: genv.processes.Process) -> None:
    labels = dict(pid=process.pid, eid=process.eid or "")

    METRICS["PROCESS_DEVICES"].labels(**labels).set(len(process.indices))

    for usage in process.used_gpu_memory:
        METRICS["PROCESS_USED_GPU_MEMORY"].labels(**labels, device=usage.index).set(
            usage.bytes
        )


def username(username: str, snapshot: genv.Snapshot) -> None:
    labels = dict(username=username)

    for metric in METRICS.filter(Type.User):
        metric.labels(**labels).set(snapshot)


async def main(args: argparse.Namespace) -> None:
    # https://github.com/prometheus/client_python#disabling-default-collector-metrics
    prometheus_client.REGISTRY.unregister(prometheus_client.GC_COLLECTOR)
    prometheus_client.REGISTRY.unregister(prometheus_client.PLATFORM_COLLECTOR)
    prometheus_client.REGISTRY.unregister(prometheus_client.PROCESS_COLLECTOR)

    prometheus_client.start_http_server(args.port)

    publish_config_files(args.config_dir, prometheus_exporter_port=args.port)

    while True:
        snapshot = await genv.snapshot()

        for metric in METRICS:
            metric.cleanup(snapshot)

        system(snapshot)

        for env in snapshot.envs:
            environment(env, snapshot.filter(eid=env.eid))

        for process_ in snapshot.processes:
            process(process_)

        for username_ in snapshot.envs.usernames:
            username(username_, snapshot.filter(username=username_))

        time.sleep(args.interval)


if __name__ == "__main__":
    args = parse_args()

    try:
        asyncio.run(main(args))
    except RuntimeError as e:
        print(e, file=sys.stderr)
        exit(1)
    except KeyboardInterrupt:
        pass
