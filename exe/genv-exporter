#!/usr/bin/env python3

import argparse
import asyncio
import sys

import genv

try:
    from genv.prometheus import metrics
    import prometheus_client
except ModuleNotFoundError as e:
    if e.name != "prometheus_client":
        raise

    print(f"ERROR: Python package '{e.name}' is required")
    exit(1)


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser()

    parser.add_argument(
        "-p",
        "--port",
        type=int,
        default=8000,
        help="Port to listen on (default: %(default)s)",
    )

    return parser.parse_args()


def system(snapshot: genv.Snapshot) -> None:
    for metric in metrics.SYSTEM:
        metric.set(snapshot)


def environment(env: genv.envs.Env, snapshot: genv.Snapshot) -> None:
    labels = dict(eid=env.eid)

    for metric in metrics.ENVIRONMENT:
        metric.labels(**labels).set(snapshot)


def process(process: genv.processes.Process) -> None:
    labels = dict(pid=process.pid, eid=process.eid or "")

    metrics.PROCESS_DEVICES.labels(**labels).set(len(process.indices))

    for usage in process.used_gpu_memory:
        metrics.PROCESS_USED_GPU_MEMORY.labels(**labels, device=usage.index).set(
            usage.bytes
        )


def username(username: str, snapshot: genv.Snapshot) -> None:
    labels = dict(username=username)

    for metric in metrics.USER:
        metric.labels(**labels).set(snapshot)


async def main(args: argparse.Namespace) -> None:
    # https://github.com/prometheus/client_python#disabling-default-collector-metrics
    prometheus_client.REGISTRY.unregister(prometheus_client.GC_COLLECTOR)
    prometheus_client.REGISTRY.unregister(prometheus_client.PLATFORM_COLLECTOR)
    prometheus_client.REGISTRY.unregister(prometheus_client.PROCESS_COLLECTOR)

    prometheus_client.start_http_server(args.port)

    while True:
        snapshot = await genv.snapshot()

        for metric in metrics.ALL:
            metric.cleanup(snapshot)

        system(snapshot)

        for env in snapshot.envs:
            environment(env, snapshot.filter(eid=env.eid))

        for process_ in snapshot.processes:
            process(process_)

        for username_ in snapshot.envs.usernames:
            username(username_, snapshot.filter(username=username_))


if __name__ == "__main__":
    args = parse_args()

    try:
        asyncio.run(main(args))
    except RuntimeError as e:
        print(e, file=sys.stderr)
        exit(1)
    except KeyboardInterrupt:
        pass
