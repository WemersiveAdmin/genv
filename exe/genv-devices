#!/usr/bin/env python3

import argparse
from datetime import datetime
import os
import subprocess
import sys
from typing import Any, Callable, Dict, List, Optional, Union

import genv

Device = Dict[Any, Any]
Devices = Dict[int, Device]


def factory() -> Dict:
    gpus_memory = subprocess.check_output("nvidia-smi --query-gpu=memory.total --format=csv,noheader", shell=True)
    gpus_memory = gpus_memory.splitlines()
    gpu_count = int(os.environ.get('GENV_DEVICES') or len(gpus_memory))

    devices_dict = {}
    for index in range(gpu_count):
        devices_dict[index] = {
            "eids": {},
            "device_gpu_memory": str(gpus_memory[index].decode()) + "mi"
        }

    return dict(devices=devices_dict)


def convert(json: Dict) -> Dict:
    """
    Converts the loaded json file.

    This is needed because some numbers are saved as strings because dictionary keys in json files must be strings.
    """
    json["devices"] = {int(index): device for index, device in json["devices"].items()}

    for index, device in json["devices"].items():
        if "device_gpu_memory" not in device.keys():
            gpu_memory = subprocess.check_output(f'nvidia-smi --id={index} --query-gpu=memory.total --format=csv,'
                                                  f'noheader', shell=True)
            device["device_gpu_memory"] = str(gpu_memory.decode()) + "mi"

    return json


def cleanup(devices: Devices, eid: Optional[str] = None, count: Optional[int] = None) -> None:
    """
    Clean up devices.

    When 'eid' is passed, only this environment is cleaned.
    When 'eid' is not passed, all deactivated environments are cleaned.

    When 'count' is passed, cleaning stops when this amount of devices are cleaned.
    """
    pred: Callable[[str], bool] = None

    if eid is not None:
        pred = lambda _: _ == eid
    else:
        eids = subprocess.check_output("genv exec envs query --query eid", shell=True).decode('utf-8').splitlines()
        pred = lambda eid: eid not in eids

    for index in sorted(devices.keys(), reverse=True):
        if count == 0:
            break

        device = devices[index]

        if len(device["eids"]) == 0:
            continue

        for candidate in list(device["eids"].keys()):
            if not pred(candidate):
                continue

            detach_device(device, candidate)

        if count is not None:
            if len(device["eids"]) == 0:
                count -= 1


def detach_device(device: Device, eid: str) -> None:
    """
    Detaches a device from an environment.
    """
    del device["eids"][eid]


def attach_devices(devices: Devices, eid: str, indices: Union[List[int], int], requested_gpu_mem: str = "") -> None:
    """
    Attaches a device or a set of devices to an environment.

    Raises 'RuntimeError' if any of the devices is not available.
    """
    if isinstance(indices, int):
        indices = [indices]

    now = datetime.now().strftime(genv.DATETIME_FMT)

    for index in indices:
        device = devices[index]
        if int(os.environ.get('GENV_DEVICE_MULTI_ATTACH', 0)) == 0:
            if len(devices[index]["eids"]) > 0:
                raise RuntimeError(f'Device {index} is not available')
        else:
            unallocated_device_gpu_mem = get_device_unallocated_memory(device)

            if requested_gpu_mem:
                if memory_to_mib(requested_gpu_mem) > unallocated_device_gpu_mem:
                    raise RuntimeError(f"Device {index} doesn't have enough memory to accommodate the environment "
                                       f"request - The device has only {unallocated_device_gpu_mem} Mib of free memory."
                                       f" The environment has requested {requested_gpu_mem}")
            else:
                if len(devices[index]["eids"]) > 0:
                    raise RuntimeError(f'Device {index} is in usage.'
                                       f' A GPU can be shared if the environment specifies a gpu-memory request')

                requested_gpu_mem = str(unallocated_device_gpu_mem) + "mib"

        devices[index]["eids"][eid] = dict(
            eid=eid,
            attached=now,
            requested_gpu_mem=requested_gpu_mem
        )


def find_available_device(devices: Devices, ignore: List[int] = [], requested_gpu_mem: str = "") -> int:
    """
    Finds an available device.
    """
    for index, device in devices.items():
        if index in ignore:
            continue

        if int(os.environ.get('GENV_DEVICE_MULTI_ATTACH', 0)) == 0 or not requested_gpu_mem:
            if len(device["eids"]) == 0:
                return index
        else:
            unallocated_device_gpu_mem = get_device_unallocated_memory(device)
            if unallocated_device_gpu_mem >= memory_to_mib(requested_gpu_mem):
                return index

    if int(os.environ.get('GENV_DEVICE_MULTI_ATTACH', 0)) == 0 or not requested_gpu_mem:
        raise RuntimeError("No available devices - all devices are fully allocated")
    else:
        raise RuntimeError(f"No available devices - can't find a device with {requested_gpu_mem} of free memory.")


def get_device_unallocated_memory(device):
    unallocated_device_gpu_mem = memory_to_mib(device["device_gpu_memory"])
    for eid in device["eids"]:
        env_req_gpu_mem = device["eids"][eid]["requested_gpu_mem"]
        if env_req_gpu_mem:
            env_req_gpu_mem = memory_to_mib(env_req_gpu_mem)
            unallocated_device_gpu_mem -= int(env_req_gpu_mem)

    return unallocated_device_gpu_mem


def find_available_devices(devices: Devices, count: int, env_mem_request: str) -> List[int]:
    """
    Finds a number of available devices.
    """
    indices = []
    for _ in range(count):
        indices.append(find_available_device(devices, ignore=indices, requested_gpu_mem=env_mem_request))

    return indices


def query(devices: Devices, eid: str) -> List[int]:
    return [index for index, device in devices.items() if eid in device["eids"]]


def memory_to_mib(cap: str) -> int:
    """
    Convert the environment memory capacity string to an integer value in MiB.
    """

    def _bytes(cap: str) -> int:
        for unit, multiplier in [
            ('b', 1),
            ('k', 1000),
            ('m', 1000 * 1000),
            ('g', 1000 * 1000 * 1000),
            ('ki', 1024),
            ('mi', 1024 * 1024),
            ('gi', 1024 * 1024 * 1024),
        ]:
            if cap.endswith(unit):
                return int(cap.replace(unit, '')) * multiplier

        return int(cap)  # the value is already in bytes if no unit was specified

    return _bytes(cap) // (1024 * 1024)


def do_attach(devices: Devices, eid: str, count: Optional[int], index: Optional[int]) -> None:
    """
    Attaches devices to an environment and prints the device indices.

    Either ensures that a specified count is attached to the environment, or explicitly tries to attach a device with a given index.
    """
    attached = query(devices, eid)
    env_mem_request = get_env_gpu_mem(args.eid)

    def ensure_count():
        current = len(attached)

        if current < count:
            if count > len(devices):
                raise RuntimeError(f"Requested more devices ({count}) than total available ({len(devices)})")

            indices = find_available_devices(devices, count - current, env_mem_request)

            attach_devices(devices, eid, indices, env_mem_request)
        elif current > count:
            cleanup(devices, eid, current - count)

    def attach_by_index():
        if index not in attached:
            attach_devices(devices, eid, index, env_mem_request)

    # TODO(raz): should this try/except be moved to main()?
    try:
        if count is not None:
            ensure_count()
        elif index is not None:
            attach_by_index()
    except RuntimeError as e:
        print(e, file=sys.stderr)
        exit(1)

    do_query(devices, eid)  # print the up-to-date device indices


def get_env_gpu_mem(eid: int) -> str:
    env_mem_query = "genv exec envs query --eid {0} --query config.gpu_memory".format(eid)
    env_mem_request = subprocess.check_output(env_mem_query, shell=True).decode('utf-8')
    env_mem_request = env_mem_request.strip()
    return env_mem_request


def do_detach(devices: Devices, eid: str, index: Optional[int]) -> None:
    if index is not None:
        if index in devices:
            device = devices[index]

            if eid in device["eids"]:
                detach_device(device, eid)
    else:
        cleanup(devices, eid)

    do_query(devices, eid)  # print the up-to-date device indices


def do_ps(devices: Devices, format: str, header: bool, timestamp: bool) -> None:
    envs = {}
    for line in subprocess.check_output("genv exec envs query --query eid config.name", shell=True).decode(
            'utf-8').splitlines():
        eid, name = line.split(',')
        envs[eid] = name

    if header:
        if format == 'csv':
            print('ID,ENV ID,ENV NAME,ATTACHED')
        elif format == 'tui':
            print('ID      ENV ID      ENV NAME        ATTACHED')

    def print_line(index, eid, name, attached):
        if format == 'csv':
            print(f'{index},{eid},{name},{attached}')
        elif format == 'tui':
            print(f'{index:<8}{eid:<12}{name:<16}{attached}')

    for index, device in devices.items():
        if len(device["eids"]) == 0:
            print_line(index, '', '', '')
        else:
            for eid, info in device["eids"].items():
                name = envs.get(eid, '')
                attached = info["attached"] if timestamp else genv.time_since(info["attached"])

                print_line(index, eid, name, attached)


def do_query(devices: Devices, eid: str) -> None:
    print(','.join(str(index) for index in query(devices, eid)))


def parse_args() -> argparse.Namespace:
    def attach(parser):
        parser.add_argument('--eid', required=True, help='Environment identifier')
        group = parser.add_mutually_exclusive_group(required=True)
        group.add_argument('--count', type=int, help='Total devices count to be attached')
        group.add_argument('--index', type=int, help='Device index to attach specifically')

    def detach(parser):
        parser.add_argument('--eid', required=True, help='Environment identifier')
        parser.add_argument('--index', type=int, help='Device index to dettach')

    def ps(parser):
        parser.add_argument('--no-header', dest='header', action='store_false', help='Do not print column headers')
        parser.add_argument('--timestamp', action='store_true', help='Print a non-prettified timestamp')
        parser.add_argument('--format', choices=['csv', 'tui'],
                            help='Output format; CSV or TUI (Text-based user interface)', default='tui')

    def query(parser):
        parser.add_argument('--eid', required=True, help='Environment identifier')

    parser = argparse.ArgumentParser(description=f'genv device manager')
    parser.add_argument('--no-cleanup', dest='cleanup', action='store_false', help='Do not perform clean up')
    parser.add_argument('--reset', action='store_true', help='Reset previous state')

    subparsers = parser.add_subparsers(dest='command')

    for command, help in [
        (attach, 'Attach devices to an environment'),
        (detach, 'Detach devices from an environment'),
        (ps, 'Print information about devices'),
        (query, 'Query devices of an environment'),
    ]:
        command(subparsers.add_parser(command.__name__, help=help))

    return parser.parse_args()


if __name__ == "__main__":
    args = parse_args()

    with genv.access_json('devices.json', factory, convert=convert, reset=args.reset) as json:
        devices: Devices = json["devices"]

        if args.cleanup:
            cleanup(devices)

        if args.command == 'attach':
            do_attach(devices, args.eid, args.count, args.index)
        elif args.command == 'detach':
            do_detach(devices, args.eid, args.index)
        elif args.command == 'ps':
            do_ps(devices, args.format, args.header, args.timestamp)
        elif args.command == 'query':
            do_query(devices, args.eid)
