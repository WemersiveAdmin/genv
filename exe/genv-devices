#!/usr/bin/env python3

import argparse
from datetime import datetime
import subprocess
import sys
from typing import Any, Callable, Dict, Iterable, List, Optional, Union

import genv

Device = Dict[Any, Any]
Devices = Dict[int, Device]

QUERIES = {
    "index": lambda device: device.index,
    "eids": lambda device: " ".join(device.eids),
    "total_memory": lambda device: device.total_memory,
    "attachments": lambda device: " ".join(
        f"{attachment.eid}+{attachment.gpu_memory or ''}+{attachment.time.replace(' ', '_')}"
        for attachment in device.attachments
    ),
}

"""
This module manages all genv devices. Each genv device represents a single Nvidia gpu.
A device can be attached to 0, 1 or more environments.
"""


def get_devices_total_memory() -> Iterable[str]:
    """
    Get total memory of all devices as string using nvidia-smi.

    Cached for performance purposes as this should not change.
    :return: A list of gpu devices memory.
            The memory at index i represents the memory (in mib) of the gpu device at index i.
    """

    def _impl():
        # move to genv.nvidia_smi once async is supported here
        return [
            f"{int(line)}mi"
            for line in subprocess.check_output(
                "GENV_BYPASS=1 nvidia-smi --query-gpu=memory.total --format=csv,noheader,nounits",
                shell=True,
            ).splitlines()
        ]

    # TODO(davidL): How do we refresh the device memory data for newly installed gpus or mock/non-mock shift?
    if not hasattr(get_devices_total_memory, "__cache__"):
        setattr(get_devices_total_memory, "__cache__", _impl())

    return getattr(get_devices_total_memory, "__cache__")


def factory() -> Dict:
    """
    Create a 'empty' state object for genv devices.
    :return: The state object (dict of dicts)
    """
    return dict(
        devices={
            index: {"eids": {}, "total_memory": total_memory}
            for index, total_memory in enumerate(get_devices_total_memory())
        }
    )


def convert(json: Dict) -> None:
    """
    Mutating the loaded genv devices state object to represent the current devices state.
    Creates the 'total_memory' section for each device (if it doesn't exist) and translate all device indexes into ints.

    The index int conversion is needed because some numbers are saved as strings.
        They are saved as strings because dictionary keys in json files must be strings.
    """
    json["devices"] = {int(index): device for index, device in json["devices"].items()}

    # "total_memory" was added in version 0.1.2
    for index, device in json["devices"].items():
        if "total_memory" not in device:
            device["total_memory"] = get_devices_total_memory()[index]


def cleanup(
    devices: Devices, eid: Optional[str] = None, count: Optional[int] = None
) -> None:
    """
    This function cleans (detaches) devices from a list of environments.
    :param devices: dictionary describing all existing genv devices.
    :param eid: When 'eid' is passed, only devices from this environment are cleaned.
            When 'eid' is not passed, devices from all deactivated environments are cleaned.
    :param count: When 'count' is passed, cleaning stops when this amount of devices are cleaned.
    :return: None
    """
    pred: Callable[[str], bool]

    if eid is not None:
        pred = lambda _: _ == eid
    else:
        pred = lambda eid: eid not in genv.envs.eids()

    for index in sorted(devices.keys(), reverse=True):
        if count == 0:
            break

        device = devices[index]

        if len(device["eids"]) == 0:
            continue

        for candidate in list(device["eids"].keys()):
            if not pred(candidate):
                continue

            detach_device(device, candidate)

        if count is not None:
            if len(device["eids"]) == 0:
                count -= 1


def detach_device(device: Device, eid: str) -> None:
    """
    Detach device from a specific environment.
    :param device: device to detach.
    :param eid: environment id to detach the device from.
    :return: None
    """
    del device["eids"][eid]


def attach_devices(
    devices: Devices,
    eid: str,
    indices: Union[List[int], int],
    env_gpu_memory: Optional[str],
) -> None:
    """
    Update devices state with the environment device attachments, including memory constraints .
    :param devices: dictionary describing all existing genv devices.
    :param eid: eid of the environment to which we will attach the devices.
    :param indices: Attached devices indices (can be one or more).
    :param env_gpu_memory: Attachment memory constraint.
    :return:
    """
    if isinstance(indices, int):
        indices = [indices]

    now = datetime.now().strftime(genv.utils.DATETIME_FMT)

    for index in indices:
        env = dict(
            eid=eid,
            attached=now,
        )

        if env_gpu_memory is not None:
            env["gpu_memory"] = env_gpu_memory

        devices[index]["eids"][eid] = env


def find_available_devices(
    snapshot: genv.devices.Snapshot,
    count: int,
    gpu_memory: Optional[str],
    allow_over_subscription: bool,
) -> Iterable[int]:
    """
    Finds available devices with respect to the optionally specified memory request.
    When thare are not enough devices available, non available devices are also used if
    over-subscription is allowed. Otherwise, RuntimeError is raised.

    :param snapshot:
    :param count: Amount of devices to find
    :param gpu_memory: Optional memory request
    :param allow_over_subscription: Use non available devices if needed

    :return: A list of device indices
    """

    available_devices = snapshot.filter(
        function=lambda device: device.available(gpu_memory)
    )

    indices = available_devices.indices

    if allow_over_subscription and len(indices) < count:
        not_available_devices = snapshot.filter(not_indices=available_devices.indices)

        # we sort in order to use the least populated devices first
        indices += sorted(
            not_available_devices.indices,
            key=lambda index: len(snapshot[index].eids),
        )

    if len(indices) < count:
        raise RuntimeError("No available devices")

    return indices[:count]


def do_attach(
    devices: Devices,
    snapshot: genv.devices.Snapshot,
    eid: str,
    count: Optional[int],
    index: Optional[int],
    allow_over_subscription: bool,
) -> None:
    """
    Attaches devices to an environment and print the device indices.
    Either ensures that a specified count is attached to the environment,
     or explicitly tries to attach a device with a given index.
    :param devices: dictionary describing all existing genv devices.
    :param eid: eid of the environment for which we attach the devices.
    :param count: number of devices to attach. Cannot be used in conjunction with the 'index' parameter.
    :param index: index of a specific device we want to attach to the environment.
     Cannot be used in conjunction with the 'count' parameter.
    :return: None
    """
    if count is None and index is None:
        # use the environment device count configuration if set
        count = genv.envs.gpus(eid)

    env_gpu_memory = genv.envs.gpu_memory(eid)
    attached_devices = snapshot.filter(eid=eid)

    def ensure_count():
        """
        Attach or detach devices from the environment according to the number of devices
        set in the environment configuration.
        """
        current = len(attached_devices)

        if current < count:
            if count > len(devices):
                raise RuntimeError(
                    f"Requested more devices ({count}) than total available ({len(devices)})"
                )

            indices = find_available_devices(
                snapshot.filter(not_indices=attached_devices.indices),
                count - current,
                env_gpu_memory,
                allow_over_subscription,
            )

            attach_devices(devices, eid, indices, env_gpu_memory)
        elif current > count:
            cleanup(devices, eid, current - count)

    def attach_by_index():
        """
        Attach a specific device to the environment.
        """
        if index not in attached_devices.indices:
            if not allow_over_subscription and not snapshot[index].available(
                env_gpu_memory
            ):
                raise RuntimeError(f"Device {index} is not available")

            attach_devices(devices, eid, index, env_gpu_memory)

    # TODO(raz): should this try/except be moved to main()?
    try:
        if count is not None:
            ensure_count()
        elif index is not None:
            attach_by_index()
    except RuntimeError as e:
        print(e, file=sys.stderr)
        exit(1)

    do_find(devices, eid)  # print the up-to-date device indices


def do_detach(devices: Devices, eid: str, index: Optional[int], quiet: bool) -> None:
    """
    Detach devices from a given environment. After detaching, print environment-devices current relationship.
    Either the device to detach is given, or a general cleanup is called on the environment.
    :param devices: dictionary describing all existing genv devices.
    :param eid: eid for the environment we are working on.
    :param index: an index of the specific device to detach.
                If no index is given a general cleanup is called on the environment.
    :return: None
    """
    if index is not None:
        if index in devices:
            device = devices[index]

            if eid in device["eids"]:
                detach_device(device, eid)
    else:
        cleanup(devices, eid)

    if not quiet:
        do_find(devices, eid)  # print the up-to-date device indices


def do_find(devices: Devices, eid: str) -> None:
    """
    Prints the indices of devices attached to the given environment.

    :param devices:
    :param eid: Environment identifier.

    :return: None
    """
    indices = [index for index, device in devices.items() if eid in device["eids"]]

    print(",".join(str(index) for index in indices))


def do_ps(
    snapshot: genv.devices.Snapshot, format: str, header: bool, timestamp: bool
) -> None:
    """
    Prints information in a human-readable fashion to the standard output.

    :param snapshot:
    :param format: Which format should be used to print the devices data - "csv" or "tui".
    :param header: a flag instructing if we should print a header as part of the output.
    :param timestamp: a flag instructing if we should print attachment time as is or relative duration (now - creation).
    :return: None
    """
    if header:
        if format == "csv":
            print("ID,ENV ID,ENV NAME,ATTACHED")
        elif format == "tui":
            print("ID      ENV ID      ENV NAME        ATTACHED")

    def print_line(index, eid, name, attached):
        if format == "csv":
            print(f"{index},{eid},{name},{attached}")
        elif format == "tui":
            print(f"{index:<8}{eid:<12}{name:<16}{attached}")

    names = genv.envs.names()

    for device in snapshot:
        if device.detached:
            print_line(device.index, "", "", "")
        else:
            for attachment in device.attachments:
                name = names.get(attachment.eid) or ""
                attached = (
                    attachment.time
                    if timestamp
                    else genv.utils.time_since(attachment.time)
                )

                print_line(device.index, attachment.eid, name, attached)


def do_query(snapshot: genv.devices.Snapshot, queries: Iterable[str]) -> None:
    """
    Queries devices.
    """
    for device in snapshot:

        def query(name: str) -> str:
            result = QUERIES[name](device)

            return "" if result is None else str(result)

        print(",".join(query(name) for name in queries))


def parse_args() -> argparse.Namespace:
    def attach(parser):
        parser.add_argument("--eid", required=True, help="Environment identifier")
        parser.add_argument(
            "--allow-over-subscription",
            action="store_true",
            help="Use unavailable devices if needed",
        )
        group = parser.add_mutually_exclusive_group()
        group.add_argument(
            # TODO(raz): remove this argument entirely.
            # either attach an environment to devices based on its configuration or by specific index
            "--count",
            type=int,
            help="Total devices count to be attached",
        )
        group.add_argument(
            "--index", type=int, help="Device index to attach specifically"
        )

    def detach(parser):
        parser.add_argument("--eid", required=True, help="Environment identifier")
        parser.add_argument("--index", type=int, help="Device index to dettach")
        parser.add_argument(
            "--quiet",
            action="store_true",
            help="Don't print updated device indexes",
        )

    def find(parser):
        parser.add_argument("--eid", required=True, help="Environment identifier")

    def ps(parser):
        parser.add_argument(
            "--no-header",
            dest="header",
            action="store_false",
            help="Do not print column headers",
        )
        parser.add_argument(
            "--timestamp", action="store_true", help="Print a non-prettified timestamp"
        )
        parser.add_argument(
            "--format",
            choices=["csv", "tui"],
            help="Output format; CSV or TUI (Text-based user interface)",
            default="tui",
        )

    def query(parser):
        parser.add_argument(
            "--query",
            "--queries",
            dest="queries",
            nargs="+",
            choices=QUERIES.keys(),
            required=True,
        )

    parser = argparse.ArgumentParser(description="genv device manager")
    parser.add_argument(
        "--no-cleanup",
        dest="cleanup",
        action="store_false",
        help="Do not perform clean up",
    )
    parser.add_argument("--reset", action="store_true", help="Reset previous state")

    subparsers = parser.add_subparsers(dest="command")

    for command, help in [
        (attach, "Attach devices to an environment"),
        (detach, "Detach devices from an environment"),
        (find, "Find the devices attached to an enviornment"),
        (ps, "Print information about devices"),
        (query, "Query devices"),
    ]:
        command(subparsers.add_parser(command.__name__, help=help))

    return parser.parse_args()


if __name__ == "__main__":
    args = parse_args()

    with genv.utils.access_json(
        "devices.json", factory, convert=convert, reset=args.reset
    ) as json:
        devices: Devices = json["devices"]

        if args.cleanup:
            cleanup(devices)

        # convert from dictionary to the snapshot representation.
        # this will be removed once the dictionary representation will no longer be used.
        snapshot = genv.devices.Snapshot(
            [
                genv.devices.Device(
                    index,
                    device["total_memory"],
                    [
                        genv.devices.Device.Attachement(
                            env["eid"],
                            env.get("gpu_memory", None),
                            env["attached"],
                        )
                        for env in device["eids"].values()
                    ],
                )
                for index, device in devices.items()
            ]
        )

        if args.command == "attach":
            do_attach(
                devices,
                snapshot,
                args.eid,
                args.count,
                args.index,
                args.allow_over_subscription,
            )
        elif args.command == "detach":
            do_detach(devices, args.eid, args.index, args.quiet)
        elif args.command == "find":
            do_find(devices, args.eid)
        elif args.command == "ps":
            do_ps(snapshot, args.format, args.header, args.timestamp)
        elif args.command == "query":
            do_query(snapshot, args.queries)
