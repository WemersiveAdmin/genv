#!/usr/bin/env python3

import argparse
from datetime import datetime
import os
import subprocess
import sys
from typing import Any, Callable, Dict, List, Optional

import genv

Device = Dict[Any, Any]
Devices = Dict[int, Device]

def factory() -> Dict:
    count = int(os.environ.get('GENV_DEVICES') or subprocess.check_output("nvidia-smi --id=0 --query-gpu=count --format=csv,noheader", shell=True))

    return dict(
        devices={ index: { "eid": -1 } for index in range(count) }
    )

def cleanup(devices: Devices, eid: Optional[int]=None) -> None:
    pred: Callable[[int], bool] = None

    if eid is not None:
        pred = lambda _: _ == eid
    else:
        eids = [int(line) for line in subprocess.check_output("genv exec envs query --query eid", shell=True).splitlines()]
        pred = lambda eid: eid not in eids

    for device in devices.values():
        if device["eid"] == -1:
            continue

        if pred(device["eid"]):
            device["eid"] = -1
            del device["attached"]

def find_available_device(devices: Devices, ignore: List[int]=[]) -> int:
    for index, device in devices.items():
        if index in ignore:
            continue

        if device["eid"] == -1:
            return index

    raise RuntimeError("No available devices")

def find_available_devices(devices: Devices, count: int) -> List[int]:
    available = len(devices)
    if count > available:
        raise RuntimeError(f"Requested more devices ({count}) than available ({available})")

    indices = []
    for _ in range(count):
        indices.append(find_available_device(devices, ignore=indices))

    return indices

def query(devices: Devices, eid: int) -> List[int]:
    return [index for index, device in devices.items() if device["eid"] == eid]

def do_attach(devices: Devices, eid: int, count: int) -> None:
    cleanup(devices, eid)

    try:
        indices = find_available_devices(devices, count)
    except RuntimeError as e:
        print(e, file=sys.stderr)
        exit(1)

    now = datetime.now().strftime(genv.DATETIME_FMT)

    for index in indices:
        devices[index]["eid"] = eid
        devices[index]["attached"] = now

    print(','.join(str(index) for index in indices))

def do_detach(devices: Devices, eid: int) -> None:
    cleanup(devices, eid)

def do_ps(devices: Devices, format: str, header: bool, timestamp: bool) -> None:
    envs = {}
    for line in subprocess.check_output("genv exec envs query --query eid config.name", shell=True).decode('utf-8').splitlines():
        eid, name = line.split(',')
        envs[int(eid)] = name

    if header:
        if format == 'csv':
            print('ID,ENV ID,ENV NAME,ATTACHED')
        elif format == 'tui':
            print('ID      ENV ID      ENV NAME        ATTACHED')

    for index, device in devices.items():
        eid = ''
        name = ''
        attached = ''

        if device["eid"] != -1:
            eid = device["eid"]
            name = envs.get(eid, '')
            attached = device["attached"] if timestamp else genv.time_since(device["attached"])

        if format == 'csv':
            print(f'{index},{eid},{name},{attached}')
        elif format == 'tui':
            print(f'{index:<8}{eid:<12}{name:<16}{attached}')

def do_query(devices: Devices, eid: int) -> None:
    print(','.join(str(index) for index in query(devices, eid)))

def parse_args() -> argparse.Namespace:
    def attach(parser):
        parser.add_argument('--eid', type=int, required=True, help='Environment identifier')
        parser.add_argument('--count', type=int, required=True, help='Devices count')

    def detach(parser):
        parser.add_argument('--eid', type=int, required=True, help='Environment identifier')

    def ps(parser):
        parser.add_argument('--no-header', dest='header', action='store_false', help='Do not print column headers')
        parser.add_argument('--timestamp', action='store_true', help='Print a non-prettified timestamp')
        parser.add_argument('--format', choices=['csv', 'tui'], help='Output format; CSV or TUI (Text-based user interface)', default='tui')

    def query(parser):
        parser.add_argument('--eid', type=int, required=True, help='Environment identifier')

    parser = argparse.ArgumentParser(description=f'genv device manager')
    parser.add_argument('--no-cleanup', dest='cleanup', action='store_false', help='Do not perform clean up')
    parser.add_argument('--reset', action='store_true', help='Reset previous state')

    subparsers = parser.add_subparsers(dest='command')

    for command, help in [
        (attach, 'Attach devices to an environment'),
        (detach, 'Detach devices from an environment'),
        (ps, 'Print information about devices'),
        (query, 'Query devices of an environment'),
    ]:
        command(subparsers.add_parser(command.__name__, help=help))

    return parser.parse_args()

if __name__ == "__main__":
    args = parse_args()

    with genv.access_json('devices.json', factory, args.reset) as json:
        # we need to convert device indices to integers. they are saved as
        # strings because dictionary keys in json files must be strings.
        json["devices"] = { int(index): device for index, device in json["devices"].items() }

        devices: Devices = json["devices"]

        if args.cleanup:
            cleanup(devices)

        if args.command == 'attach':
            do_attach(devices, args.eid, args.count)
        elif args.command == 'detach':
            do_detach(devices, args.eid)
        elif args.command == 'ps':
            do_ps(devices, args.format, args.header, args.timestamp)
        elif args.command == 'query':
            do_query(devices, args.eid)
