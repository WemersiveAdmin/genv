#!/usr/bin/env python3

import argparse
from datetime import datetime
import os
from typing import Any, List, Optional, Union

import genv

QUERIES = {
    "eid": lambda env: env.eid,
    "creation": lambda env: env.creation,
    "uid": lambda env: env.uid,
    "username": lambda env: env.username,
    "config.name": lambda env: env.config.name,
    "config.gpus": lambda env: env.config.gpus,
    "config.gpu_memory": lambda env: env.config.gpu_memory,
    "pids": lambda env: " ".join(str(pid) for pid in env.pids),
    "kernel_ids": lambda env: " ".join(kernel_id for kernel_id in env.kernel_ids),
}


def convert(o: Union[genv.envs.Snapshot, Any]) -> genv.envs.Snapshot:
    """
    Converts the loaded state object to a snapshot if it not already is.
    """
    def _get_field(obj, field, cls, *args):
        return (
            getattr(obj, field, *args)
            if isinstance(obj, cls)
            else obj.get(field, *args)
        )

    def _get_env_field(env, field, *args):
        return _get_field(env, field, genv.envs.Env, *args)

    def _get_config_field(env, field, *args):
        config = _get_env_field(env, "config")

        return _get_field(config, field, genv.envs.Env.Config, *args)

    # the following logic converts state files from versions <= 0.9.0.
    # note that the indicator is 'o.envs' and not 'o' itself because the structure of
    # the state file from these versions was similar to the snapshot structure (a single
    # key named "envs") so the JSON decoder parsed the object as a snapshot object.
    if isinstance(o.envs, dict):
        o = genv.envs.Snapshot(
            [
                genv.envs.Env(
                    _get_env_field(env, "eid"),
                    _get_env_field(env, "uid"),
                    _get_env_field(env, "creation"),
                    _get_env_field(env, "username", None),
                    genv.envs.Env.Config(
                        _get_config_field(env, "name", None),
                        _get_config_field(env, "gpu_memory", None),
                        _get_config_field(env, "gpus", None),
                    ),
                    _get_env_field(env, "pids", []),
                    _get_env_field(env, "kernel_ids", []),
                )
                for env in o.envs.values()
            ]
        )

    return o


def do_activate(
    snapshot: genv.envs.Snapshot,
    eid: str,
    uid: int,
    username: Optional[str],
    pid: Optional[int],
    kernel_id: Optional[str],
) -> None:
    """
    Activates an environment.
    Creates the environment if does not exist already.
    Attaches the given process id or and jupyter kernel ids if exist.
    """
    if eid not in snapshot:
        snapshot.activate(
            eid=eid,
            uid=uid,
            creation=datetime.now().strftime(genv.utils.DATETIME_FMT),
            username=username,
        )

    snapshot[eid].attach(pid=pid, kernel_id=kernel_id)


def do_config(
    snapshot: genv.envs.Snapshot, eid: str, command: str, args: argparse.Namespace
) -> None:
    """
    Update environment config variables - either set a specific variable or clear it.

    :param command: a string describing which variable in the environment config to change
    :param args: parameters for the config change.
                For example - gpus count variable, clear/not clear config variable, etc.
    :return: None
    """
    if eid not in snapshot:
        return

    env = snapshot[eid]

    def gpus(count: Optional[int], clear: bool) -> None:
        if count is not None:
            env.config.gpus = count

        if clear:
            env.config.gpus = None

    def name(name: Optional[str], clear: bool) -> None:
        if name is not None:
            env.config.name = name

        if clear:
            env.config.name = None

    def gpu_memory(gpu_memory: Optional[str], clear: bool) -> None:
        # TODO(raz): validate the specification

        if gpu_memory is not None:
            env.config.gpu_memory = gpu_memory

        if clear:
            env.config.gpu_memory = None

    if command == "gpus":
        gpus(args.count, args.clear)
    elif command == "name":
        name(args.name, args.clear)
    elif command == "gpu-memory":
        gpu_memory(args.gpu_memory, args.clear)


def do_deactivate(snapshot: genv.envs.Snapshot, pid: int) -> None:
    """
    Detaches the given process identifier.
    """
    snapshot.cleanup(poll_pid=lambda pid_: pid_ != pid)


def do_find(
    snapshot: genv.envs.Snapshot, pid: Optional[int], kernel_id: Optional[str]
) -> None:
    """
    Prints the environment identifiers of the given process or kernel.
    """
    for env in snapshot:
        if (pid is not None) and (pid not in env.pids):
            continue

        if (kernel_id is not None) and (kernel_id not in env.kernel_ids):
            continue

        print(env.eid)


def do_ps(
    snapshot: genv.envs.Snapshot, format: str, header: bool, timestamp: bool
) -> None:
    """
    Print environments data in a human-readable fashion to the stdio.

    :param format: Which format should be used to print the environment data - csv or tui (default: tui).
    :param header: a flag instructing if we should print a header as part of the output (default: print header).
    :param timestamp: a flag instructing if we should print creation time as is or relative duration (now - creation).
                    (default: relative duration)
    :return: None
    """
    if header:
        if format == "csv":
            print("ID,USER,NAME,CREATED,PID(S)")
        elif format == "tui":
            print("ID      USER            NAME            CREATED              PID(S)")

    for env in snapshot:
        eid = env.eid
        user = f"{env.username}({env.uid})" if env.username else env.uid
        name = env.config.name or ""
        created = env.creation if timestamp else genv.utils.time_since(env.creation)
        pids = " ".join(str(pid) for pid in env.pids)
        # TODO(raz): print kernel ids

        if format == "csv":
            print(f"{eid},{user},{name},{created},{pids}")
        elif format == "tui":
            print(f"{eid:<8}{user:<16}{name:<16}{created:<21}{pids}")


def do_query(
    snapshot: genv.envs.Snapshot, eid: Optional[str], queries: List[str]
) -> None:
    """
    Queries environment data using a query string. The queries results will be printed into the stdio.
    """
    eids = [eid] if eid is not None else snapshot.eids

    for eid in eids:
        if eid not in snapshot:
            continue

        env = snapshot[eid]

        def query(name: str) -> str:
            result = QUERIES[name](env)

            return "" if result is None else str(result)

        print(",".join(query(name) for name in queries))


def parse_args() -> argparse.Namespace:
    """
    Set all possible genv environments commands and their arguments.
    :return:
    """

    def activate(parser):
        parser.add_argument("--eid", required=True, help="Environment identifier")
        parser.add_argument(
            "--uid", type=int, required=True, help="User identifier"
        )  # TODO(raz): should we make this optional?
        parser.add_argument("--username", help="User name")

        group = parser.add_mutually_exclusive_group(required=True)

        group.add_argument("--pid", type=int, help="Process identifier")
        group.add_argument("--kernel-id", help="Jupyter kernel identifier")

    def config(parser):
        def gpus(parser):
            group = parser.add_mutually_exclusive_group(required=True)
            group.add_argument("--count", type=int, help="Device count")
            group.add_argument(
                "--clear", action="store_true", help="Clear device count"
            )

        def name(parser):
            group = parser.add_mutually_exclusive_group(required=True)
            group.add_argument("--name", help="Environment name")
            group.add_argument(
                "--clear", action="store_true", help="Clear environment name"
            )

        def gpu_memory(parser):
            group = parser.add_mutually_exclusive_group(required=True)
            group.add_argument("--gpu-memory", help="Environment GPU memory capacity")
            group.add_argument(
                "--clear",
                action="store_true",
                help="Clear environment GPU memory capacity",
            )

        parser.add_argument("--eid", required=True, help="Environment identifier")

        subparsers = parser.add_subparsers(dest="config", required=True)

        for option in [
            (gpus, "Configure device count for environment"),
            (name, "Configure environment name"),
            (gpu_memory, "gpu-memory", "Configure environment GPU memory capacity"),
        ]:
            if len(option) == 2:
                command, help = option
                name_ = command.__name__
            else:
                command, name_, help = option

            command(subparsers.add_parser(name_, help=help))

    def deactivate(parser):
        parser.add_argument("--pid", type=int, required=True, help="Process identifier")

    def find(parser):
        group = parser.add_mutually_exclusive_group(required=True)

        group.add_argument("--pid", type=int, help="Process identifier")
        group.add_argument("--kernel-id", help="Jupyter kernel identifier")

    def ps(parser):
        parser.add_argument(
            "--no-header",
            dest="header",
            action="store_false",
            help="Do not print column headers",
        )
        parser.add_argument(
            "--timestamp", action="store_true", help="Print a non-prettified timestamp"
        )
        parser.add_argument(
            "--format",
            choices=["csv", "tui"],
            help="Output format; CSV or TUI (Text-based user interface)",
            default="tui",
        )

    def query(parser):
        parser.add_argument("--eid", help="Environment identifier")
        parser.add_argument(
            "--query",
            "--queries",
            dest="queries",
            nargs="+",
            choices=QUERIES.keys(),
            required=True,
        )

    parser = argparse.ArgumentParser(description="genv environment manager")
    parser.add_argument(
        "--no-cleanup",
        dest="cleanup",
        action="store_false",
        help="Do not perform clean up",
    )
    parser.add_argument("--reset", action="store_true", help="Reset previous state")

    subparsers = parser.add_subparsers(dest="command")

    for command, help in [
        (activate, "Activate a process or a Jupyter kernel"),
        (config, "Configure an environment"),
        (deactivate, "Deactivate a process or a Jupyter kernel"),
        (find, "Find the environment of a process or a Jupyter kernel"),
        (ps, "Print information about active environments"),
        (query, "Query environments or a specific one"),
    ]:
        command(subparsers.add_parser(command.__name__, help=help))

    return parser.parse_args()


if __name__ == "__main__":
    args = parse_args()

    path = genv.utils.get_temp_file_path("envs.json")

    with genv.os_.access_lock(f"{path}.lock"):
        if os.path.exists(path) and not args.reset:
            snapshot = genv.utils.load_state(
                path,
                convert=convert,
                json_decoder=genv.json_.JSONDecoder,
            )
        else:
            snapshot = genv.envs.Snapshot([])

        if args.cleanup:
            snapshot.cleanup()

        if args.command == "activate":
            do_activate(
                snapshot,
                args.eid,
                args.uid,
                args.username,
                args.pid,
                args.kernel_id,
            )
        elif args.command == "config":
            do_config(snapshot, args.eid, command=args.config, args=args)
        elif args.command == "deactivate":
            do_deactivate(snapshot, args.pid)
        elif args.command == "find":
            do_find(snapshot, args.pid, args.kernel_id)
        elif args.command == "ps":
            do_ps(snapshot, args.format, args.header, args.timestamp)
        elif args.command == "query":
            do_query(snapshot, args.eid, args.queries)

        genv.utils.save_state(
            snapshot,
            path,
            json_encoder=genv.json_.JSONEncoder,
        )
