#!/usr/bin/env python3

import argparse
import asyncio
from dataclasses import dataclass
import sys
from typing import Iterable, Optional, Set, Tuple

import genv.devices
import genv.nvidia_smi
import genv.os_
import genv.users


# TODO(raz): use a proper logger instead of printing to stderr


@dataclass
class Process(genv.nvidia_smi.Process):
    eid: Optional[str]

    def __hash__(self) -> int:
        return super().__hash__()


@dataclass
class Snapshot:
    processes: Iterable[Process]
    user_attachments: genv.users.Attachments


@dataclass
class Report:
    processes_to_terminate: Set[Process]
    envs_to_detach: Set[Tuple[str, int, Optional[str]]]


class Survey:
    def __init__(self) -> None:
        self._processes_to_terminate = set()
        self._envs_to_detach = set()

    def terminate(self, process: Process) -> None:
        self._processes_to_terminate.add(process)

    def detach(self, eid: str, index: int, username: Optional[str]) -> None:
        self._envs_to_detach.add((eid, index, username))

    def report(self, snapshot: Snapshot) -> Report:
        return Report(
            self._processes_to_terminate.union(
                set(
                    process
                    for eid, index, _ in self._envs_to_detach
                    for process in snapshot.processes
                    if process.eid == eid and process.gpu_index == index
                )
            ),
            self._envs_to_detach,
        )


async def take_snapshot() -> Snapshot:
    """
    Takes a snapshot of the current state of the system.
    This includes running processes, active environments and device attachments.
    """
    processes = []

    for process in await genv.nvidia_smi.compute_processes():
        try:
            eid = genv.os_.get_process_environ(process.pid).get(
                "GENV_ENVIRONMENT_ID", None
            )

            process_ = Process(
                process.gpu_index,
                process.pid,
                process.used_gpu_memory,
                eid,
            )

            processes.append(process_)
        except PermissionError:
            print(
                f"[WARNING] Not enough permissions to query environment of process {process.pid}",
                file=sys.stderr,
            )
        except FileNotFoundError:
            print(f"[DEBUG] Process {process.pid} already terminated", file=sys.stderr)

    user_attachments = genv.users.attachments()

    return Snapshot(processes, user_attachments)


def execute_report(report: Report) -> None:
    """
    Terminates processes and detaches environments from devices according to the given report.
    """
    for process in report.processes_to_terminate:
        try:
            print(
                f"Terminating process {process.pid} from environment {process.eid or 'N/A'} that is running on GPU {process.gpu_index} and using {process.used_gpu_memory}"
            )

            genv.os_.terminate(process.pid)
        except PermissionError:
            print(
                f"[ERROR] Not enough permissions to terminate process {process.pid}",
                file=sys.stderr,
            )
        except ProcessLookupError:
            print(f"[DEBUG] Process {process.pid} already terminated", file=sys.stderr)

    for eid, index, username in report.envs_to_detach:
        print(
            f"Detaching environment {eid} of user {username or 'N/A'} from device {index}"
        )

        genv.devices.detach(eid, index)


def enforce_non_env_processes(snapshot: Snapshot, survey: Survey) -> None:
    for process in snapshot.processes:
        if process.eid is not None:
            continue

        print(f"Process {process.pid} is not running in a GPU environment")

        survey.terminate(process)


def enforce_max_devices_per_user(
    snapshot: Snapshot, survey: Survey, maximum: int
) -> None:
    for username, attachments in snapshot.user_attachments.items():
        attached = len(attachments)

        if attached <= maximum:
            continue

        over = attached - maximum

        print(
            f"User {username} is using {attached} devices which is {over} more than the maximum allowed"
        )

        for index in list(attachments.keys())[:over]:
            for eid in attachments[index]:
                survey.detach(eid, index, username)


def parse_args() -> argparse.Namespace:
    """
    Parses the arguments passed to this executable.

    :return: Argument values
    """

    parser = argparse.ArgumentParser()

    parser.add_argument(
        "--interval",
        type=int,
        default=10,
        help="interval in seconds between enforcement cycles; 0 means run once (default: %(default)s)",
    )

    enforcements = parser.add_argument_group("enforcements")

    def add_enforcement(
        name: str, *, dest: str, help: str, default: bool = True
    ) -> None:
        """
        Adds a mutual exclusive group for an enforcement flag with true and false actions.
        """
        group = enforcements.add_mutually_exclusive_group()

        group.add_argument(
            f"--{name}",
            action="store_true",
            default=default,
            help=help + " (default: %(default)s)",
            dest=dest,
        )

        group.add_argument(
            f"--no-{name}",
            action="store_false",
            dest=dest,
        )

    add_enforcement(
        "non-env-processes",
        dest="terminate_non_env_processes",
        help="terminate processes that are not running in a GPU environment",
        default=False,
    )

    enforcements.add_argument(
        "--max-devices-per-user",
        type=int,
        help="maximum allowed attached devices for each user",
    )

    return parser.parse_args()


async def main() -> None:
    """
    Runs the main logic and enforces GPU usage according to the arguments.

    :return: None
    """
    args = parse_args()

    while True:
        snapshot = await take_snapshot()
        survey = Survey()

        if args.terminate_non_env_processes:
            enforce_non_env_processes(snapshot, survey)

        if args.max_devices_per_user is not None:
            enforce_max_devices_per_user(
                snapshot, survey, maximum=args.max_devices_per_user
            )

        report = survey.report(snapshot)

        execute_report(report)

        if args.interval == 0:
            break

        await asyncio.sleep(args.interval)


if __name__ == "__main__":
    try:
        asyncio.run(main())
    except RuntimeError as e:
        print(e, file=sys.stderr)
        exit(1)
    except KeyboardInterrupt:
        pass
