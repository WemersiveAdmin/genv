#!/usr/bin/env python3

import argparse
import asyncio
from dataclasses import dataclass
import sys
from typing import Iterable, Optional, Set

import genv


# TODO(raz): use a proper logger instead of printing to stderr


@dataclass
class Process(genv.nvidia_smi.Process):
    eid: Optional[str]

    def __hash__(self) -> int:
        return super().__hash__()


@dataclass
class Snapshot:
    processes: Iterable[Process]


class Report:
    """
    A holder class for the cumulative conclusion of all enforcers.
    """

    def __init__(self) -> None:
        self.processes_to_terminate: Set[Process] = set()


async def take_snapshot() -> Snapshot:
    """
    Takes a snapshot of the current state of the system.
    This includes running processes, active environments and device attachments.
    """
    processes = []

    for process in await genv.nvidia_smi.compute_processes():
        try:
            eid = genv.get_process_environ(process.pid).get("GENV_ENVIRONMENT_ID", None)

            process_ = Process(
                process.gpu_index,
                process.pid,
                process.used_gpu_memory,
                eid,
            )

            processes.append(process_)
        except PermissionError:
            print(
                f"[WARNING] Not enough permissions to query environment of process {process.pid}",
                file=sys.stderr,
            )
        except FileNotFoundError:
            print(f"[DEBUG] Process {process.pid} already terminated", file=sys.stderr)

    return Snapshot(processes)


def enforce_non_env_processes(snapshot: Snapshot, report: Report) -> None:
    for process in snapshot.processes:
        if process.eid is None:
            print(
                f"Process {process.pid} is not running in a GPU environment",
                file=sys.stderr,
            )

            report.processes_to_terminate.add(process)


def parse_args() -> argparse.Namespace:
    """
    Parses the arguments passed to this executable.

    :return: Argument values
    """

    parser = argparse.ArgumentParser()

    parser.add_argument(
        "--interval",
        type=int,
        default=10,
        help="Interval in seconds between enforcement cycles; 0 means run once (default: %(default)s)",
    )

    enforcements = parser.add_argument_group("enforcements")

    def add_enforcement(
        name: str, *, dest: str, help: str, default: bool = True
    ) -> None:
        """
        Adds a mutual exclusive group for an enforcement flag with true and false actions.
        """
        group = enforcements.add_mutually_exclusive_group()

        group.add_argument(
            f"--{name}",
            action="store_true",
            default=default,
            help=help + " (default: %(default)s)",
            dest=dest,
        )

        group.add_argument(
            f"--no-{name}",
            action="store_false",
            dest=dest,
        )

    add_enforcement(
        "non-env-processes",
        dest="terminate_non_env_processes",
        help="Terminate processes that are not running in a GPU environment",
        default=False,
    )

    return parser.parse_args()


async def main() -> None:
    """
    Runs the main logic and enforces GPU usage according to the arguments.

    :return: None
    """
    args = parse_args()

    while True:
        snapshot = await take_snapshot()
        report = Report()

        if args.terminate_non_env_processes:
            enforce_non_env_processes(snapshot, report)

        for process in report.processes_to_terminate:
            try:
                print(
                    f"Terminating process {process.pid} from environment {process.eid or 'N/A'} that is running on GPU {process.gpu_index} and using {process.used_gpu_memory}"
                )
                genv.terminate(process.pid)
            except PermissionError:
                print(
                    f"[ERROR] Not enough permissions to terminate process {process.pid}",
                    file=sys.stderr,
                )
            except ProcessLookupError:
                print(
                    f"[DEBUG] Process {process.pid} already terminated", file=sys.stderr
                )

        if args.interval == 0:
            break

        await asyncio.sleep(args.interval)


if __name__ == "__main__":
    try:
        asyncio.run(main())
    except RuntimeError as e:
        print(e, file=sys.stderr)
        exit(1)
    except KeyboardInterrupt:
        pass
