#!/usr/bin/env python3

import argparse
import asyncio
import os
import sys

try:
    import genv
except ModuleNotFoundError:
    # we manually set the system path if the Genv Python package is not installed.
    # this is for backward compatability with installation from source.
    sys.path.append(os.path.realpath(os.path.join(os.path.dirname(__file__), "../py")))

    import genv


def parse_args() -> argparse.Namespace:
    """
    Parses the arguments passed to this executable.

    :return: Argument values
    """

    parser = argparse.ArgumentParser()

    parser.add_argument(
        "--interval",
        type=int,
        default=10,
        help="interval in seconds between enforcement cycles; 0 means run once (default: %(default)s)",
    )

    enforcements = parser.add_argument_group("enforcements")

    def add_enforcement(
        name: str, *, dest: str, help: str, default: bool = True
    ) -> None:
        """
        Adds a mutual exclusive group for an enforcement flag with true and false actions.
        """
        group = enforcements.add_mutually_exclusive_group()

        group.add_argument(
            f"--{name}",
            action="store_true",
            default=default,
            help=help + " (default: %(default)s)",
            dest=dest,
        )

        group.add_argument(
            f"--no-{name}",
            action="store_false",
            dest=dest,
        )

    add_enforcement(
        "non-env-processes",
        dest="non_env_processes",
        help="terminate processes that are not running in a GPU environment",
        default=False,
    )

    add_enforcement(
        "env-devices",
        dest="env_devices",
        help="enforce environment attached devices",
        default=True,
    )

    add_enforcement(
        "env-memory",
        dest="env_memory",
        help="enforce environment memory capacity if set",
        default=True,
    )

    enforcements.add_argument(
        "--max-devices-per-user",
        type=int,
        help="maximum allowed attached devices for each user",
    )

    return parser.parse_args()


async def main() -> None:
    """
    Runs the main logic and enforces GPU usage according to the arguments.

    :return: None
    """
    args = parse_args()

    while True:
        with genv.utils.global_lock():
            snapshot = await genv.core.snapshot()

        survey = genv.entities.enforce.Survey(snapshot)

        if args.non_env_processes:
            genv.enforce.rules.non_env_processes(survey)

        if args.env_devices:
            genv.enforce.rules.env_devices(survey)

        if args.env_memory:
            genv.enforce.rules.env_memory(survey)

        if args.max_devices_per_user is not None:
            genv.enforce.rules.max_devices_per_user(
                survey, maximum=args.max_devices_per_user
            )

        with genv.utils.global_lock():
            genv.enforce.execute(survey.report)

        if args.interval == 0:
            break

        await asyncio.sleep(args.interval)


if __name__ == "__main__":
    try:
        asyncio.run(main())
    except RuntimeError as e:
        print(e, file=sys.stderr)
        exit(1)
    except KeyboardInterrupt:
        pass
