#!/usr/bin/env python3

import argparse
import asyncio
import sys
import time

import genv

try:
    from genv.metrics import Collection, Metric, Type, publish_config_files, SPECS
    import prometheus_client
except ModuleNotFoundError as e:
    if e.name != "prometheus_client":
        raise

    print(f"ERROR: Python package '{e.name}' is required", file=sys.stderr)
    exit(1)


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser()

    parser.add_argument(
        "--config-dir",
        default=genv.utils.get_temp_file_path("metrics"),
        help="Directory to create Prometheus and Grafana config files at (default: %(default)s)",
    )

    parser.add_argument(
        "-p",
        "--port",
        type=int,
        default=8000,
        help="Port for Prometheus exporter to listen on (default: %(default)s)",
    )

    parser.add_argument(
        "-i",
        "--interval",
        type=int,
        default=10,
        help="Interval in seconds between collections (default: %(default)s)",
    )

    return parser.parse_args()


METRICS = Collection(
    {
        name: Metric(
            spec.name,
            spec.documentation,
            spec.labelnames,
            type=spec.type,
            convert=spec.convert,
            filter=spec.filter,
        )
        for name, spec in SPECS.items()
    }
)


async def main(args: argparse.Namespace) -> None:
    # https://github.com/prometheus/client_python#disabling-default-collector-metrics
    prometheus_client.REGISTRY.unregister(prometheus_client.GC_COLLECTOR)
    prometheus_client.REGISTRY.unregister(prometheus_client.PLATFORM_COLLECTOR)
    prometheus_client.REGISTRY.unregister(prometheus_client.PROCESS_COLLECTOR)

    prometheus_client.start_http_server(args.port)

    publish_config_files(args.config_dir, prometheus_exporter_port=args.port)

    while True:
        snapshot = await genv.snapshot()

        for metric in METRICS:
            metric.cleanup(snapshot)

        for metric in METRICS.filter(Type.System):
            metric.set(snapshot)

        for env in snapshot.envs:
            env_snapshot = snapshot.filter(eid=env.eid)

            for metric in METRICS.filter(Type.Environment):
                metric.labels(eid=env.eid).set(env_snapshot)

        for process in snapshot.processes:
            labels = dict(
                pid=process.pid,
                eid=process.eid or "",
            )

            METRICS["PROCESS_DEVICES"].labels(**labels).set(len(process.indices))

            for usage in process.used_gpu_memory:
                METRICS["PROCESS_USED_GPU_MEMORY"].labels(
                    **labels, device=usage.index
                ).set(usage.bytes)

        for username in snapshot.envs.usernames:
            user_snapshot = snapshot.filter(username=username)

            for metric in METRICS.filter(Type.User):
                metric.labels(username=username).set(user_snapshot)

        time.sleep(args.interval)


if __name__ == "__main__":
    args = parse_args()

    try:
        asyncio.run(main(args))
    except RuntimeError as e:
        print(e, file=sys.stderr)
        exit(1)
    except KeyboardInterrupt:
        pass
